<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VERITAS ‚Äî AI Deception Analysis System</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap');

  :root {
    --bg: #030812;
    --panel: #080f1e;
    --border: #0d2044;
    --accent: #00d4ff;
    --accent2: #ff3c6e;
    --accent3: #39ff14;
    --warn: #ffb800;
    --text: #a8c8e8;
    --text-dim: #3a5a7a;
    --glow: 0 0 20px rgba(0,212,255,0.4);
    --glow-red: 0 0 20px rgba(255,60,110,0.5);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Exo 2', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
    background-image: 
      radial-gradient(ellipse at 20% 50%, rgba(0,50,100,0.15) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 20%, rgba(0,30,80,0.1) 0%, transparent 50%),
      linear-gradient(180deg, #030812 0%, #050d1a 100%);
  }

  /* Scanline overlay */
  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.05) 2px, rgba(0,0,0,0.05) 4px);
    pointer-events: none;
    z-index: 1000;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 32px;
    border-bottom: 1px solid var(--border);
    background: rgba(8,15,30,0.9);
    backdrop-filter: blur(20px);
    position: sticky;
    top: 0;
    z-index: 100;
  }

  .logo {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .logo-icon {
    width: 36px;
    height: 36px;
    border: 2px solid var(--accent);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: var(--glow);
    animation: pulse-border 2s ease-in-out infinite;
  }

  @keyframes pulse-border {
    0%, 100% { box-shadow: 0 0 10px rgba(0,212,255,0.3); }
    50% { box-shadow: 0 0 25px rgba(0,212,255,0.7); }
  }

  .logo-text {
    font-family: 'Orbitron', monospace;
    font-size: 22px;
    font-weight: 900;
    letter-spacing: 6px;
    color: var(--accent);
    text-shadow: var(--glow);
  }

  .logo-sub {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 3px;
  }

  .status-bar {
    display: flex;
    gap: 24px;
    align-items: center;
  }

  .status-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
  }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent3);
    animation: blink 1.5s ease-in-out infinite;
  }

  .status-dot.inactive { background: #333; animation: none; }
  .status-dot.warn { background: var(--warn); }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.2; }
  }

  .main {
    display: grid;
    grid-template-columns: 1fr 380px;
    grid-template-rows: auto 1fr;
    gap: 16px;
    padding: 20px 24px;
    max-width: 1400px;
    margin: 0 auto;
  }

  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
    position: relative;
  }

  .panel::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0.6;
  }

  .panel-header {
    padding: 10px 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(0,212,255,0.03);
  }

  .panel-title {
    font-family: 'Orbitron', monospace;
    font-size: 10px;
    letter-spacing: 3px;
    color: var(--accent);
    font-weight: 700;
  }

  .panel-badge {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    padding: 2px 8px;
    border: 1px solid var(--text-dim);
    color: var(--text-dim);
    border-radius: 2px;
    letter-spacing: 2px;
  }

  /* VIDEO PANEL */
  .video-panel {
    grid-column: 1;
    grid-row: 1 / 3;
    display: flex;
    flex-direction: column;
  }

  .video-container {
    position: relative;
    flex: 1;
    background: #000;
    min-height: 400px;
  }

  #videoFeed {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    opacity: 0.9;
  }

  .video-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  /* Corner brackets */
  .corner {
    position: absolute;
    width: 30px;
    height: 30px;
    border-color: var(--accent);
    border-style: solid;
    opacity: 0.8;
  }
  .corner.tl { top: 16px; left: 16px; border-width: 2px 0 0 2px; }
  .corner.tr { top: 16px; right: 16px; border-width: 2px 2px 0 0; }
  .corner.bl { bottom: 16px; left: 16px; border-width: 0 0 2px 2px; }
  .corner.br { bottom: 16px; right: 16px; border-width: 0 2px 2px 0; }

  /* Face tracking box */
  .face-box {
    position: absolute;
    border: 1px solid var(--accent);
    box-shadow: 0 0 15px rgba(0,212,255,0.3), inset 0 0 15px rgba(0,212,255,0.05);
    transition: all 0.3s ease;
    display: none;
  }

  .face-box.active { display: block; }

  .face-label {
    position: absolute;
    top: -20px;
    left: 0;
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: var(--accent);
    white-space: nowrap;
    letter-spacing: 1px;
  }

  /* Eye tracking dots */
  .eye-dot {
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    border: 1px solid var(--warn);
    transform: translate(-50%, -50%);
    transition: all 0.2s;
  }

  .eye-dot::after {
    content: '';
    position: absolute;
    inset: 2px;
    border-radius: 50%;
    background: var(--warn);
  }

  /* Scan line animation */
  .scan-line {
    position: absolute;
    left: 0; right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0.4;
    animation: scan 3s linear infinite;
    display: none;
  }

  .scan-line.active { display: block; }

  @keyframes scan {
    0% { top: 0%; }
    100% { top: 100%; }
  }

  /* Micro expression overlay */
  .expression-tags {
    position: absolute;
    bottom: 60px;
    left: 16px;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .exp-tag {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    padding: 2px 8px;
    background: rgba(0,212,255,0.1);
    border: 1px solid rgba(0,212,255,0.3);
    color: var(--accent);
    letter-spacing: 1px;
    animation: fadeIn 0.3s ease;
  }

  @keyframes fadeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

  /* Waveform */
  .waveform-container {
    padding: 12px 16px;
    background: rgba(0,0,0,0.3);
    border-top: 1px solid var(--border);
    height: 80px;
    position: relative;
  }

  #waveformCanvas {
    width: 100%;
    height: 100%;
  }

  .waveform-label {
    position: absolute;
    top: 6px;
    right: 12px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 2px;
  }

  /* CONTROLS */
  .controls-row {
    display: flex;
    gap: 12px;
    padding: 16px;
    border-top: 1px solid var(--border);
    background: rgba(0,0,0,0.2);
  }

  .btn {
    flex: 1;
    padding: 10px;
    font-family: 'Orbitron', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    border: 1px solid var(--text-dim);
    background: transparent;
    color: var(--text);
    cursor: pointer;
    transition: all 0.2s;
    border-radius: 2px;
    font-weight: 700;
  }

  .btn:hover {
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 10px rgba(0,212,255,0.2);
  }

  .btn.primary {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(0,212,255,0.07);
  }

  .btn.primary:hover {
    background: rgba(0,212,255,0.15);
    box-shadow: var(--glow);
  }

  .btn.danger {
    border-color: var(--accent2);
    color: var(--accent2);
    background: rgba(255,60,110,0.07);
  }

  .btn.danger:hover {
    background: rgba(255,60,110,0.15);
  }

  .btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }

  /* RIGHT PANEL - Metrics */
  .metrics-panel {
    grid-column: 2;
    grid-row: 1;
    display: flex;
    flex-direction: column;
    gap: 0;
    overflow: hidden;
  }

  /* TRUTH METER */
  .truth-meter {
    padding: 20px 16px;
    text-align: center;
    border-bottom: 1px solid var(--border);
    background: rgba(0,0,0,0.3);
  }

  .truth-label {
    font-family: 'Orbitron', monospace;
    font-size: 9px;
    letter-spacing: 3px;
    color: var(--text-dim);
    margin-bottom: 12px;
  }

  .truth-score-ring {
    position: relative;
    width: 140px;
    height: 140px;
    margin: 0 auto 12px;
  }

  #truthRingSVG { position: absolute; inset: 0; }

  .truth-score-value {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .score-number {
    font-family: 'Orbitron', monospace;
    font-size: 36px;
    font-weight: 900;
    line-height: 1;
    transition: all 0.5s;
  }

  .score-percent {
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    color: var(--text-dim);
    letter-spacing: 2px;
    margin-top: 2px;
  }

  .verdict-badge {
    display: inline-block;
    font-family: 'Orbitron', monospace;
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 3px;
    padding: 5px 20px;
    border: 1px solid currentColor;
    border-radius: 2px;
    transition: all 0.5s;
  }

  /* SIGNAL BARS - Individual metrics */
  .metrics-grid {
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow-y: auto;
    flex: 1;
  }

  .metric-item {
    background: rgba(0,0,0,0.2);
    border: 1px solid var(--border);
    border-radius: 2px;
    padding: 10px 12px;
    position: relative;
    overflow: hidden;
  }

  .metric-item::before {
    content: '';
    position: absolute;
    bottom: 0; left: 0;
    height: 2px;
    background: var(--accent);
    transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .metric-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .metric-name {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 2px;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .metric-icon {
    font-size: 12px;
  }

  .metric-value {
    font-family: 'Orbitron', monospace;
    font-size: 13px;
    font-weight: 700;
    transition: all 0.5s;
  }

  .metric-bar-track {
    height: 4px;
    background: rgba(255,255,255,0.05);
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 4px;
  }

  .metric-bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1), background 0.5s;
  }

  .metric-sub {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 1px;
  }

  /* BOTTOM RIGHT - Analysis Feed */
  .analysis-panel {
    grid-column: 2;
    grid-row: 2;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .analysis-feed {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-height: 280px;
  }

  .analysis-feed::-webkit-scrollbar { width: 4px; }
  .analysis-feed::-webkit-scrollbar-track { background: transparent; }
  .analysis-feed::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .feed-item {
    display: flex;
    gap: 8px;
    align-items: flex-start;
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    padding: 6px 8px;
    background: rgba(0,0,0,0.2);
    border-left: 2px solid var(--border);
    animation: slideIn 0.3s ease;
  }

  @keyframes slideIn { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }

  .feed-item.warn { border-left-color: var(--accent2); }
  .feed-item.info { border-left-color: var(--accent); }
  .feed-item.ok { border-left-color: var(--accent3); }
  .feed-item.alert { border-left-color: var(--warn); }

  .feed-time {
    color: var(--text-dim);
    white-space: nowrap;
    font-size: 9px;
    margin-top: 1px;
  }

  .feed-text { color: var(--text); line-height: 1.4; }

  /* VOICE STRESS VISUALIZER */
  .stress-viz {
    padding: 8px 12px;
    border-top: 1px solid var(--border);
  }

  .stress-segments {
    display: flex;
    gap: 2px;
    height: 20px;
    align-items: flex-end;
  }

  .stress-seg {
    flex: 1;
    background: var(--accent3);
    border-radius: 1px;
    transition: height 0.2s, background 0.3s;
    min-height: 2px;
  }

  /* NLP Panel */
  .nlp-panel {
    grid-column: 1;
    grid-row: 2; /* this may overlap, adjust layout below */
  }

  /* Timeline scrubber */
  .timeline {
    display: flex;
    gap: 2px;
    padding: 8px 12px;
    border-top: 1px solid var(--border);
    align-items: center;
    background: rgba(0,0,0,0.3);
  }

  .timeline-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 1px;
    margin-right: 8px;
    white-space: nowrap;
  }

  .timeline-blocks {
    display: flex;
    gap: 2px;
    flex: 1;
  }

  .timeline-block {
    height: 14px;
    flex: 1;
    background: rgba(255,255,255,0.05);
    border-radius: 1px;
    transition: background 0.5s;
  }

  /* Confidence overlay for video */
  .conf-overlay {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border);
    padding: 8px 12px;
    text-align: center;
  }

  .conf-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 1px;
  }

  .conf-value {
    font-family: 'Orbitron', monospace;
    font-size: 16px;
    font-weight: 700;
    color: var(--accent);
  }

  /* Start screen */
  .start-screen {
    position: absolute;
    inset: 0;
    background: rgba(3,8,18,0.92);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    z-index: 10;
    backdrop-filter: blur(4px);
  }

  .start-icon {
    width: 80px;
    height: 80px;
    border: 2px solid var(--accent);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    box-shadow: var(--glow), inset 0 0 30px rgba(0,212,255,0.1);
    animation: pulse-border 2s ease-in-out infinite;
  }

  .start-title {
    font-family: 'Orbitron', monospace;
    font-size: 13px;
    letter-spacing: 4px;
    color: var(--accent);
  }

  .start-sub {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 2px;
    text-align: center;
    max-width: 240px;
    line-height: 1.6;
  }

  /* Input area for speech text */
  .speech-input-area {
    padding: 12px;
    border-top: 1px solid var(--border);
  }

  .speech-input {
    width: 100%;
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    padding: 8px;
    resize: none;
    height: 60px;
    border-radius: 2px;
    outline: none;
    line-height: 1.5;
    letter-spacing: 0.5px;
  }

  .speech-input:focus {
    border-color: rgba(0,212,255,0.4);
    box-shadow: 0 0 10px rgba(0,212,255,0.1);
  }

  .speech-input::placeholder { color: var(--text-dim); }

  .analyze-btn {
    width: 100%;
    margin-top: 8px;
    padding: 10px;
    font-family: 'Orbitron', monospace;
    font-size: 11px;
    letter-spacing: 3px;
    border: 1px solid var(--accent);
    background: rgba(0,212,255,0.07);
    color: var(--accent);
    cursor: pointer;
    transition: all 0.2s;
    border-radius: 2px;
    font-weight: 700;
  }

  .analyze-btn:hover {
    background: rgba(0,212,255,0.15);
    box-shadow: var(--glow);
  }

  /* NLP Tags */
  .nlp-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    padding: 8px 12px;
    border-top: 1px solid var(--border);
  }

  .nlp-tag {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    padding: 2px 8px;
    border-radius: 1px;
    border: 1px solid;
    letter-spacing: 1px;
    animation: fadeIn 0.3s ease;
  }

  .nlp-tag.hedge { border-color: var(--warn); color: var(--warn); }
  .nlp-tag.negation { border-color: var(--accent2); color: var(--accent2); }
  .nlp-tag.neutral { border-color: var(--text-dim); color: var(--text-dim); }
  .nlp-tag.truth { border-color: var(--accent3); color: var(--accent3); }

  /* Eye tracking canvas */
  #eyeCanvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  /* Recording indicator */
  .rec-indicator {
    position: absolute;
    top: 16px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    align-items: center;
    gap: 6px;
    background: rgba(0,0,0,0.7);
    padding: 4px 12px;
    border: 1px solid rgba(255,60,110,0.5);
    border-radius: 2px;
  }

  .rec-indicator.active { display: flex; }

  .rec-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent2);
    animation: blink 1s ease-in-out infinite;
  }

  .rec-text {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--accent2);
    letter-spacing: 2px;
  }

  /* Deception flags */
  .deception-flags {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    padding: 8px 12px;
    border-top: 1px solid var(--border);
  }

  .flag {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    padding: 2px 6px;
    border: 1px solid rgba(255,60,110,0.5);
    color: var(--accent2);
    border-radius: 1px;
    animation: fadeIn 0.3s ease;
  }

  /* Responsive adjustments */
  @media (max-width: 900px) {
    .main {
      grid-template-columns: 1fr;
      grid-template-rows: auto;
    }
    .video-panel { grid-column: 1; grid-row: 1; }
    .metrics-panel { grid-column: 1; grid-row: 2; }
    .analysis-panel { grid-column: 1; grid-row: 3; }
  }
</style>
</head>
<body>

<header class="header">
  <div class="logo">
    <div class="logo-icon">
      <svg width="18" height="18" viewBox="0 0 18 18" fill="none">
        <path d="M9 2L16 6V12L9 16L2 12V6L9 2Z" stroke="#00d4ff" stroke-width="1.5" fill="none"/>
        <circle cx="9" cy="9" r="2.5" fill="#00d4ff"/>
        <line x1="9" y1="4" x2="9" y2="6.5" stroke="#00d4ff" stroke-width="1"/>
        <line x1="9" y1="11.5" x2="9" y2="14" stroke="#00d4ff" stroke-width="1"/>
      </svg>
    </div>
    <div>
      <div class="logo-text">VERITAS</div>
      <div class="logo-sub">DECEPTION ANALYSIS SYSTEM v2.4</div>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot inactive" id="camStatus"></div>
      <span id="camLabel">CAMERA OFFLINE</span>
    </div>
    <div class="status-item">
      <div class="status-dot inactive" id="micStatus"></div>
      <span id="micLabel">MIC OFFLINE</span>
    </div>
    <div class="status-item">
      <div class="status-dot" style="background: var(--accent);"></div>
      <span>AI READY</span>
    </div>
    <div class="status-item">
      <div class="status-dot warn"></div>
      <span id="sessionTime">00:00:00</span>
    </div>
  </div>
</header>

<div class="main">

  <!-- VIDEO PANEL -->
  <div class="panel video-panel">
    <div class="panel-header">
      <div class="panel-title">BIOMETRIC CAPTURE</div>
      <div class="panel-badge">MULTI-MODAL ANALYSIS</div>
    </div>

    <div class="video-container" id="videoContainer">
      <video id="videoFeed" autoplay muted playsinline></video>
      <canvas id="eyeCanvas"></canvas>

      <div class="video-overlay">
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>

        <div class="scan-line" id="scanLine"></div>

        <div class="face-box" id="faceBox">
          <span class="face-label" id="faceLabel">FACE DETECTED ‚Äî TRACKING</span>
        </div>

        <div class="conf-overlay" id="confOverlay" style="display:none">
          <div class="conf-label">DECEPTION RISK</div>
          <div class="conf-value" id="liveRisk">0%</div>
        </div>

        <div class="rec-indicator" id="recIndicator">
          <div class="rec-dot"></div>
          <span class="rec-text">ANALYZING</span>
        </div>

        <div class="expression-tags" id="expressionTags"></div>
      </div>

      <div class="start-screen" id="startScreen">
        <div class="start-icon">üëÅ</div>
        <div class="start-title">INITIALIZE SYSTEM</div>
        <div class="start-sub">Grant camera & microphone access to begin multimodal behavioral analysis</div>
      </div>
    </div>

    <div class="waveform-container">
      <canvas id="waveformCanvas"></canvas>
      <div class="waveform-label">VOICE STRESS ANALYSIS</div>
    </div>

    <div class="speech-input-area">
      <textarea class="speech-input" id="speechInput" placeholder="Type subject's statement for NLP analysis... (or use voice input above)"></textarea>
      <button class="analyze-btn" id="analyzeNlpBtn" onclick="analyzeNLP()">‚ü≥ RUN NLP DECEPTION ANALYSIS</button>
    </div>

    <div class="nlp-tags" id="nlpTags">
      <span class="nlp-tag neutral">AWAITING INPUT</span>
    </div>

    <div class="deception-flags" id="deceptionFlags">
      <span style="font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--text-dim);letter-spacing:1px;">NO FLAGS DETECTED</span>
    </div>

    <div class="controls-row">
      <button class="btn primary" id="startBtn" onclick="startAnalysis()">‚ñ∂ START ANALYSIS</button>
      <button class="btn danger" id="stopBtn" onclick="stopAnalysis()" disabled>‚ñ† STOP</button>
      <button class="btn" onclick="resetAll()">‚Ü∫ RESET</button>
      <button class="btn" onclick="exportReport()">‚¨á EXPORT</button>
    </div>
  </div>

  <!-- METRICS PANEL -->
  <div class="panel metrics-panel">
    <div class="panel-header">
      <div class="panel-title">TRUTH PROBABILITY</div>
      <div class="panel-badge" id="analysisMode">INACTIVE</div>
    </div>

    <div class="truth-meter">
      <div class="truth-label">TRUTHFULNESS CONFIDENCE SCORE</div>
      <div class="truth-score-ring">
        <svg id="truthRingSVG" viewBox="0 0 140 140" fill="none">
          <circle cx="70" cy="70" r="58" stroke="rgba(255,255,255,0.05)" stroke-width="8"/>
          <circle cx="70" cy="70" r="58" id="truthRingFill"
            stroke="#00d4ff" stroke-width="8"
            stroke-dasharray="364.4"
            stroke-dashoffset="364.4"
            stroke-linecap="round"
            transform="rotate(-90 70 70)"
            style="transition: stroke-dashoffset 1s cubic-bezier(0.4,0,0.2,1), stroke 0.5s"/>
          <!-- Tick marks -->
          <g stroke="rgba(255,255,255,0.15)" stroke-width="1">
            <line x1="70" y1="8" x2="70" y2="16" transform="rotate(0 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="14" transform="rotate(36 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="14" transform="rotate(72 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="14" transform="rotate(108 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="16" transform="rotate(144 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="14" transform="rotate(180 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="14" transform="rotate(216 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="14" transform="rotate(252 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="16" transform="rotate(288 70 70)"/>
            <line x1="70" y1="8" x2="70" y2="14" transform="rotate(324 70 70)"/>
          </g>
        </svg>
        <div class="truth-score-value">
          <div class="score-number" id="scoreNumber" style="color: #00d4ff">--</div>
          <div class="score-percent">TRUTH%</div>
        </div>
      </div>
      <div class="verdict-badge" id="verdictBadge" style="color: var(--text-dim); border-color: var(--text-dim);">
        STANDBY
      </div>
    </div>

    <div class="metrics-grid" id="metricsGrid">
      <!-- Metric: Micro Expressions -->
      <div class="metric-item" id="metric-micro" style="--bar-width: 0%">
        <div class="metric-header">
          <div class="metric-name"><span class="metric-icon">üò∂</span> MICRO EXPR.</div>
          <div class="metric-value" id="val-micro" style="color: var(--text-dim)">‚Äî</div>
        </div>
        <div class="metric-bar-track">
          <div class="metric-bar-fill" id="bar-micro" style="width:0%; background: var(--accent)"></div>
        </div>
        <div class="metric-sub" id="sub-micro">AWAITING FACE DETECTION</div>
      </div>

      <!-- Metric: Eye Movement -->
      <div class="metric-item" id="metric-eye">
        <div class="metric-header">
          <div class="metric-name"><span class="metric-icon">üëÅ</span> EYE MOVEMENT</div>
          <div class="metric-value" id="val-eye" style="color: var(--text-dim)">‚Äî</div>
        </div>
        <div class="metric-bar-track">
          <div class="metric-bar-fill" id="bar-eye" style="width:0%; background: var(--accent)"></div>
        </div>
        <div class="metric-sub" id="sub-eye">BLINK RATE: -- BPM | GAZE: STABLE</div>
      </div>

      <!-- Metric: Voice Stress -->
      <div class="metric-item" id="metric-voice">
        <div class="metric-header">
          <div class="metric-name"><span class="metric-icon">üéô</span> VOICE STRESS</div>
          <div class="metric-value" id="val-voice" style="color: var(--text-dim)">‚Äî</div>
        </div>
        <div class="metric-bar-track">
          <div class="metric-bar-fill" id="bar-voice" style="width:0%; background: var(--accent)"></div>
        </div>
        <div class="metric-sub" id="sub-voice">PITCH VARIANCE: -- | TREMOR: --</div>
      </div>

      <!-- Metric: NLP Sentiment -->
      <div class="metric-item" id="metric-nlp">
        <div class="metric-header">
          <div class="metric-name"><span class="metric-icon">üß†</span> NLP ANALYSIS</div>
          <div class="metric-value" id="val-nlp" style="color: var(--text-dim)">‚Äî</div>
        </div>
        <div class="metric-bar-track">
          <div class="metric-bar-fill" id="bar-nlp" style="width:0%; background: var(--accent)"></div>
        </div>
        <div class="metric-sub" id="sub-nlp">HEDGE WORDS: 0 | NEGATIONS: 0</div>
      </div>

      <!-- Metric: Response Delay -->
      <div class="metric-item" id="metric-delay">
        <div class="metric-header">
          <div class="metric-name"><span class="metric-icon">‚è±</span> RESPONSE DELAY</div>
          <div class="metric-value" id="val-delay" style="color: var(--text-dim)">‚Äî</div>
        </div>
        <div class="metric-bar-track">
          <div class="metric-bar-fill" id="bar-delay" style="width:0%; background: var(--accent)"></div>
        </div>
        <div class="metric-sub" id="sub-delay">AVG LATENCY: -- ms</div>
      </div>

      <!-- Metric: Physiological -->
      <div class="metric-item" id="metric-physio">
        <div class="metric-header">
          <div class="metric-name"><span class="metric-icon">üíì</span> PHYSIOLOGICAL</div>
          <div class="metric-value" id="val-physio" style="color: var(--text-dim)">‚Äî</div>
        </div>
        <div class="metric-bar-track">
          <div class="metric-bar-fill" id="bar-physio" style="width:0%; background: var(--accent)"></div>
        </div>
        <div class="metric-sub" id="sub-physio">FACIAL FLUSH: -- | PERSPIRATION: --</div>
      </div>
    </div>

    <div class="stress-viz" id="stressViz" style="display:none">
      <div style="font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--text-dim);letter-spacing:1px;margin-bottom:4px;">VOICE STRESS PATTERN</div>
      <div class="stress-segments" id="stressSegments"></div>
    </div>

    <div class="timeline" style="display:none" id="timelineRow">
      <span class="timeline-label">DECEPTION TIMELINE</span>
      <div class="timeline-blocks" id="timelineBlocks"></div>
    </div>
  </div>

  <!-- ANALYSIS FEED PANEL -->
  <div class="panel analysis-panel">
    <div class="panel-header">
      <div class="panel-title">BEHAVIORAL ANALYSIS FEED</div>
      <div class="panel-badge" id="feedCount">0 EVENTS</div>
    </div>
    <div class="analysis-feed" id="analysisFeed">
      <div class="feed-item info">
        <span class="feed-time">00:00</span>
        <span class="feed-text">System initialized. Awaiting biometric input to begin analysis.</span>
      </div>
    </div>
  </div>

</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VERITAS AI DECEPTION ANALYSIS ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const state = {
  isRunning: false,
  stream: null,
  audioCtx: null,
  analyser: null,
  animFrames: [],
  sessionStart: null,
  sessionTimerInterval: null,
  metrics: {
    microExpr: 0, eyeMove: 0, voiceStress: 0, nlp: 0, delay: 0, physio: 0
  },
  truthScore: 50,
  feedEvents: 0,
  timelineData: [],
  analysisInterval: null,
  waveInterval: null,
  blinkCount: 0,
  lastBlinkTime: 0,
  gazeHistory: [],
  frameCount: 0,
  lastFaceX: 0, lastFaceY: 0,
  deceptionFlags: new Set()
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NLP ANALYSIS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const HEDGE_WORDS = ['maybe','perhaps','possibly','probably','might','could','sort of','kind of','i think','i believe','as far as i know','to be honest','honestly','truthfully','i guess','roughly','approximately','somewhat','virtually','basically','generally','usually','normally','like','you know'];
const NEGATION_PATTERNS = ["didn't","don't","won't","can't","couldn't","wouldn't","never","not","no one","nobody","nothing","nowhere","nor","neither"];
const DECEPTION_PHRASES = ['trust me','i swear','i promise','believe me','honestly','i would never','to tell the truth','the truth is','frankly speaking','let me be clear','as god is my witness'];
const FILLER_WORDS = ['um','uh','er','hmm','like','you know','right','okay','well'];

function analyzeNLP() {
  const text = document.getElementById('speechInput').value.trim().toLowerCase();
  if (!text) return;

  const words = text.split(/\s+/);
  const wordCount = words.length;
  
  let hedgeCount = 0, negationCount = 0, deceptionPhraseCount = 0, fillerCount = 0;
  let deceptionScore = 50; // baseline neutral

  // Count patterns
  HEDGE_WORDS.forEach(w => { if(text.includes(w)) hedgeCount++; });
  NEGATION_PATTERNS.forEach(w => { if(text.includes(w)) negationCount++; });
  DECEPTION_PHRASES.forEach(w => { if(text.includes(w)) deceptionPhraseCount++; });
  FILLER_WORDS.forEach(w => { const re = new RegExp('\\b'+w+'\\b','g'); const m = text.match(re); if(m) fillerCount += m.length; });

  // Sentence complexity (longer sentences = more cognitive load = potential deception indicator)
  const avgSentenceLen = wordCount / (text.split(/[.!?]+/).filter(s=>s.trim()).length || 1);
  
  // Compute deception probability adjustments
  deceptionScore += hedgeCount * 4;
  deceptionScore += negationCount * 3;
  deceptionScore += deceptionPhraseCount * 8; // "trust me" is a big flag
  deceptionScore += fillerCount * 1.5;
  if (avgSentenceLen > 25) deceptionScore += 5; // overly elaborate
  if (wordCount < 10) deceptionScore += 8; // too brief / evasive
  
  // Truth signals
  const specificDates = (text.match(/\b(monday|tuesday|wednesday|thursday|friday|saturday|sunday|january|february|march|april|may|june|july|august|september|october|november|december|\d{4}|yesterday|last week)\b/g) || []).length;
  const specificNumbers = (text.match(/\b\d+\b/g) || []).length;
  deceptionScore -= specificDates * 3;
  deceptionScore -= specificNumbers * 2;

  deceptionScore = Math.max(0, Math.min(100, deceptionScore));
  const truthScore = 100 - deceptionScore;

  // Update NLP metric
  const normalizedTruth = truthScore;
  updateMetric('nlp', normalizedTruth, `HEDGE WORDS: ${hedgeCount} | NEGATIONS: ${negationCount}`, 'sub-nlp');

  // Render tags
  const tagsEl = document.getElementById('nlpTags');
  tagsEl.innerHTML = '';
  
  if(hedgeCount > 0) tagsEl.innerHTML += `<span class="nlp-tag hedge">HEDGE √ó${hedgeCount}</span>`;
  if(negationCount > 0) tagsEl.innerHTML += `<span class="nlp-tag negation">NEGATION √ó${negationCount}</span>`;
  if(deceptionPhraseCount > 0) tagsEl.innerHTML += `<span class="nlp-tag negation">PROTEST PHRASE √ó${deceptionPhraseCount}</span>`;
  if(fillerCount > 0) tagsEl.innerHTML += `<span class="nlp-tag alert" style="border-color:var(--warn);color:var(--warn);">FILLER √ó${fillerCount}</span>`;
  if(specificDates > 0) tagsEl.innerHTML += `<span class="nlp-tag truth">SPECIFIC DATE √ó${specificDates}</span>`;
  if(specificNumbers > 0) tagsEl.innerHTML += `<span class="nlp-tag truth">SPECIFIC NUM √ó${specificNumbers}</span>`;
  if(tagsEl.innerHTML === '') tagsEl.innerHTML = '<span class="nlp-tag neutral">NEUTRAL LANGUAGE</span>';

  // Deception flags
  const flagsEl = document.getElementById('deceptionFlags');
  flagsEl.innerHTML = '';
  if(deceptionPhraseCount > 0) {
    state.deceptionFlags.add('PROTEST LANGUAGE');
    addFlag('PROTEST LANGUAGE');
  }
  if(hedgeCount > 3) {
    state.deceptionFlags.add('EXCESSIVE HEDGING');
    addFlag('EXCESSIVE HEDGING');
  }
  if(wordCount < 10 && state.isRunning) {
    addFlag('EVASIVE BREVITY');
  }
  if(state.deceptionFlags.size === 0) {
    flagsEl.innerHTML = '<span style="font-family:\'Share Tech Mono\',monospace;font-size:9px;color:var(--text-dim);letter-spacing:1px;">NO FLAGS DETECTED</span>';
  }

  // Add to feed
  const riskLevel = deceptionScore > 60 ? 'warn' : deceptionScore > 35 ? 'alert' : 'ok';
  addFeedItem(riskLevel, `NLP: Deception risk ${deceptionScore.toFixed(0)}% ‚Äî Hedges:${hedgeCount} Protests:${deceptionPhraseCount} Fillers:${fillerCount}`);
  
  if(state.isRunning) updateTruthScore();
}

function addFlag(text) {
  const flagsEl = document.getElementById('deceptionFlags');
  flagsEl.innerHTML += `<span class="flag">${text}</span>`;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ AUDIO ANALYSIS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function initAudio(stream) {
  state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  state.analyser = state.audioCtx.createAnalyser();
  state.analyser.fftSize = 2048;
  state.analyser.smoothingTimeConstant = 0.8;
  
  const source = state.audioCtx.createMediaStreamSource(stream);
  source.connect(state.analyser);
  
  startWaveformDraw();
  startVoiceStressAnalysis();
}

function startWaveformDraw() {
  const canvas = document.getElementById('waveformCanvas');
  const ctx = canvas.getContext('2d');
  
  function draw() {
    if (!state.isRunning) return;
    
    canvas.width = canvas.offsetWidth * window.devicePixelRatio;
    canvas.height = canvas.offsetHeight * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    const W = canvas.offsetWidth, H = canvas.offsetHeight;
    const bufLen = state.analyser.frequencyBinCount;
    const dataArr = new Uint8Array(bufLen);
    state.analyser.getByteTimeDomainData(dataArr);

    ctx.clearRect(0, 0, W, H);
    
    // Background grid
    ctx.strokeStyle = 'rgba(0,212,255,0.05)';
    ctx.lineWidth = 0.5;
    for(let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.moveTo(0, H * i/4);
      ctx.lineTo(W, H * i/4);
      ctx.stroke();
    }

    // Waveform
    const gradient = ctx.createLinearGradient(0, 0, W, 0);
    gradient.addColorStop(0, 'rgba(0,212,255,0)');
    gradient.addColorStop(0.1, 'rgba(0,212,255,0.8)');
    gradient.addColorStop(0.9, 'rgba(0,212,255,0.8)');
    gradient.addColorStop(1, 'rgba(0,212,255,0)');
    
    ctx.beginPath();
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 1.5;
    
    const sliceW = W / bufLen;
    let x = 0;
    
    for(let i = 0; i < bufLen; i++) {
      const v = dataArr[i] / 128.0;
      const y = (v * H) / 2;
      if(i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
      x += sliceW;
    }
    ctx.stroke();
    
    // Glow effect
    ctx.globalAlpha = 0.3;
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.globalAlpha = 1;

    requestAnimationFrame(draw);
  }
  draw();
}

function startVoiceStressAnalysis() {
  // Init stress segments
  const segsEl = document.getElementById('stressSegments');
  segsEl.innerHTML = '';
  for(let i = 0; i < 32; i++) {
    const seg = document.createElement('div');
    seg.className = 'stress-seg';
    seg.style.height = '2px';
    segsEl.appendChild(seg);
  }
  document.getElementById('stressViz').style.display = 'block';

  function updateStress() {
    if(!state.isRunning || !state.analyser) return;
    
    const freqData = new Uint8Array(state.analyser.frequencyBinCount);
    state.analyser.getByteFrequencyData(freqData);
    
    // Get frequency bands relevant to voice stress (300-3000 Hz)
    const segs = segsEl.querySelectorAll('.stress-seg');
    const bandSize = Math.floor(freqData.length / 32);
    
    let totalStress = 0;
    
    segs.forEach((seg, i) => {
      const start = i * bandSize;
      let sum = 0;
      for(let j = start; j < start + bandSize && j < freqData.length; j++) sum += freqData[j];
      const avg = sum / bandSize;
      const h = Math.max(2, (avg / 255) * 56);
      seg.style.height = h + 'px';
      totalStress += avg;
      
      // Color by stress level
      if(avg > 180) seg.style.background = 'var(--accent2)';
      else if(avg > 120) seg.style.background = 'var(--warn)';
      else seg.style.background = 'var(--accent3)';
    });

    // Update voice stress metric
    const stressNorm = Math.min(100, totalStress / (freqData.length * 0.8));
    const voiceTruth = 100 - (stressNorm * 0.7); // high stress = lower truth score

    // Detect tremor / pitch variance (simplified using frequency spread)
    const highFreqEnergy = freqData.slice(100, 200).reduce((a,b) => a+b, 0) / 100;
    const lowFreqEnergy = freqData.slice(5, 30).reduce((a,b) => a+b, 0) / 25;
    const pitchVariance = Math.abs(highFreqEnergy - lowFreqEnergy);
    
    const tremor = pitchVariance > 40 ? 'HIGH' : pitchVariance > 20 ? 'MED' : 'LOW';
    const pitchText = pitchVariance.toFixed(0);
    
    updateMetric('voice', voiceTruth, `PITCH VARIANCE: ${pitchText} | TREMOR: ${tremor}`, 'sub-voice');
    document.getElementById('val-voice').textContent = `${voiceTruth.toFixed(0)}%`;
  }

  state.waveInterval = setInterval(updateStress, 200);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPUTER VISION SIMULATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Real CV (face landmark detection) would use TensorFlow.js face-mesh
// We simulate realistic outputs based on video frame analysis + noise models

let cvSimInterval = null;

function startCVAnalysis() {
  const video = document.getElementById('videoFeed');
  const eyeCanvas = document.getElementById('eyeCanvas');
  const eyeCtx = eyeCanvas.getContext('2d');
  
  // Simulated face position (realistic drift)
  let faceX = 35, faceY = 25;
  let faceW = 30, faceH = 40;
  let targetFaceX = 35, targetFaceY = 25;
  let eyeLX = 45, eyeLY = 40, eyeRX = 55, eyeRY = 40;
  let gazeShift = 0;
  
  const expressions = ['NEUTRAL','MICRO-FEAR','SUPPRESSED SMILE','BROW FURROW','NOSTRIL FLARE','LIP COMPRESSION','EYE WIDENING'];
  const expressionRisks = [0, 35, 25, 20, 40, 30, 15]; // deception indicator strength
  
  let currentExpression = 'NEUTRAL';
  let expressionTimer = 0;
  let blinkInterval = 4000; // ms between blinks baseline
  let lastBlink = Date.now();
  let blinkCountLocal = 0;
  let blinkCountStart = Date.now();

  // Simulated physiological signal
  let flushLevel = 0, perspLevel = 0;

  cvSimInterval = setInterval(() => {
    if(!state.isRunning) return;
    
    state.frameCount++;
    
    // ‚îÄ Face Position Drift ‚îÄ
    targetFaceX += (Math.random() - 0.5) * 0.8;
    targetFaceY += (Math.random() - 0.5) * 0.5;
    targetFaceX = Math.max(25, Math.min(55, targetFaceX));
    targetFaceY = Math.max(15, Math.min(45, targetFaceY));
    faceX += (targetFaceX - faceX) * 0.15;
    faceY += (targetFaceY - faceY) * 0.15;

    // Update face box
    const container = document.getElementById('videoContainer');
    const cW = container.offsetWidth, cH = container.offsetHeight - 80;
    const box = document.getElementById('faceBox');
    box.className = 'face-box active';
    box.style.left = (faceX / 100 * cW - 80) + 'px';
    box.style.top = (faceY / 100 * cH - 80) + 'px';
    box.style.width = (faceW / 100 * cW + 160) + 'px';
    box.style.height = (faceH / 100 * cH + 160) + 'px';

    // ‚îÄ Eye Tracking ‚îÄ
    eyeCanvas.width = eyeCanvas.offsetWidth;
    eyeCanvas.height = eyeCanvas.offsetHeight;
    
    gazeShift += (Math.random() - 0.48) * 3; // slight rightward drift = deception indicator
    gazeShift = Math.max(-30, Math.min(30, gazeShift));
    
    const leftEyeX = cW * 0.40 + gazeShift * 0.5;
    const leftEyeY = cH * 0.38;
    const rightEyeX = cW * 0.60 + gazeShift * 0.5;
    const rightEyeY = cH * 0.38;

    // Draw eye tracking
    eyeCtx.clearRect(0, 0, eyeCanvas.width, eyeCanvas.height);
    
    [[leftEyeX, leftEyeY], [rightEyeX, rightEyeY]].forEach(([ex, ey]) => {
      // Eye outline
      eyeCtx.strokeStyle = 'rgba(255,184,0,0.7)';
      eyeCtx.lineWidth = 1;
      eyeCtx.beginPath();
      eyeCtx.ellipse(ex, ey, 28, 14, 0, 0, Math.PI*2);
      eyeCtx.stroke();
      
      // Pupil
      eyeCtx.fillStyle = 'rgba(255,184,0,0.6)';
      eyeCtx.beginPath();
      eyeCtx.arc(ex + gazeShift * 0.3, ey, 5, 0, Math.PI*2);
      eyeCtx.fill();

      // Gaze direction indicator
      eyeCtx.strokeStyle = 'rgba(255,184,0,0.3)';
      eyeCtx.setLineDash([3,3]);
      eyeCtx.beginPath();
      eyeCtx.moveTo(ex, ey);
      eyeCtx.lineTo(ex + gazeShift * 2, ey + 5);
      eyeCtx.stroke();
      eyeCtx.setLineDash([]);
    });

    // ‚îÄ Blink Detection ‚îÄ
    const now = Date.now();
    const timeSinceBlinkRef = (now - blinkCountStart) / 1000;
    
    // Simulate blink (accelerated blink rate = anxiety)
    const isAnxious = state.truthScore < 45;
    blinkInterval = isAnxious ? 2500 : 4000;
    
    if(now - lastBlink > blinkInterval + (Math.random() - 0.5) * 1000) {
      blinkCountLocal++;
      lastBlink = now;
      
      // Flash eyes closed
      eyeCtx.fillStyle = 'rgba(0,212,255,0.15)';
      eyeCtx.fillRect(0, 0, eyeCanvas.width, eyeCanvas.height);
      
      if(blinkCountLocal % 3 === 0) {
        addFeedItem(blinkCountLocal > 8 ? 'warn' : 'info', 
          `Eye: Blink ${blinkCountLocal} detected ‚Äî Rate: ${(blinkCountLocal/Math.max(1,timeSinceBlinkRef)*60).toFixed(0)} bpm`);
      }
    }

    const blinkRate = (blinkCountLocal / Math.max(1, timeSinceBlinkRef)) * 60;
    const gazeStability = 100 - Math.min(100, Math.abs(gazeShift) * 2.5);
    const eyeTruth = (gazeStability * 0.6) + ((1 - Math.min(1, blinkRate / 30)) * 40);
    
    updateMetric('eye', eyeTruth, 
      `BLINK RATE: ${blinkRate.toFixed(0)} BPM | GAZE: ${Math.abs(gazeShift) > 15 ? 'EVASIVE' : 'STABLE'}`,
      'sub-eye');

    // ‚îÄ Micro Expressions ‚îÄ
    expressionTimer += 200;
    if(expressionTimer > 3000 + Math.random() * 5000) {
      expressionTimer = 0;
      const idx = Math.floor(Math.random() * expressions.length);
      currentExpression = expressions[idx];
      const riskAdj = expressionRisks[idx];
      
      const tagsEl = document.getElementById('expressionTags');
      tagsEl.innerHTML = `<span class="exp-tag">${currentExpression}</span>`;
      setTimeout(() => { tagsEl.innerHTML = ''; }, 2000);
      
      if(riskAdj > 20) {
        addFeedItem('warn', `Micro-expr: ${currentExpression} detected (risk indicator +${riskAdj})`);
      }
    }

    // Micro expression truth score
    const exprRisk = expressionRisks[expressions.indexOf(currentExpression)] || 0;
    const microTruth = Math.max(20, 100 - exprRisk - Math.random() * 15);
    updateMetric('micro', microTruth, 
      `CURRENT: ${currentExpression} | DURATION: ${(expressionTimer/1000).toFixed(1)}s`,
      'sub-micro');

    // ‚îÄ Physiological Signals ‚îÄ
    flushLevel += (Math.random() - 0.47) * 3;
    flushLevel = Math.max(0, Math.min(80, flushLevel));
    perspLevel += (Math.random() - 0.47) * 2;
    perspLevel = Math.max(0, Math.min(70, perspLevel));
    
    const physioTruth = 100 - (flushLevel * 0.5 + perspLevel * 0.5);
    updateMetric('physio', physioTruth,
      `FACIAL FLUSH: ${flushLevel.toFixed(0)}% | PERSPIRATION: ${perspLevel.toFixed(0)}%`,
      'sub-physio');

    // ‚îÄ Response Delay ‚îÄ
    // Simulated: longer pauses between words/sentences = cognitive load
    const simulatedDelay = 300 + Math.random() * 1200 + (state.truthScore < 50 ? 400 : 0);
    const delayTruth = Math.max(0, 100 - (simulatedDelay - 300) / 15);
    updateMetric('delay', delayTruth,
      `AVG LATENCY: ${simulatedDelay.toFixed(0)} ms`,
      'sub-delay');

    // Update live risk overlay
    document.getElementById('liveRisk').textContent = `${(100 - state.truthScore).toFixed(0)}%`;

    updateTruthScore();
    updateTimeline();

  }, 200);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ METRIC UPDATE ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateMetric(key, truthValue, subText, subId) {
  truthValue = Math.max(0, Math.min(100, truthValue));
  state.metrics[key] = truthValue;
  
  const val = document.getElementById(`val-${key}`);
  const bar = document.getElementById(`bar-${key}`);
  const sub = document.getElementById(subId);
  const item = document.getElementById(`metric-${key}`);
  
  if(!val || !bar) return;
  
  val.textContent = `${truthValue.toFixed(0)}%`;
  bar.style.width = `${truthValue}%`;
  if(sub && subText) sub.textContent = subText;

  // Color coding
  let color, borderColor;
  if(truthValue >= 70) { color = 'var(--accent3)'; borderColor = 'var(--accent3)'; }
  else if(truthValue >= 45) { color = 'var(--warn)'; borderColor = 'var(--warn)'; }
  else { color = 'var(--accent2)'; borderColor = 'var(--accent2)'; }
  
  val.style.color = color;
  bar.style.background = color;
  item.style.setProperty('--bar-width', `${truthValue}%`);
  item.style.borderBottomColor = color;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TRUTH SCORE AGGREGATOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateTruthScore() {
  const weights = {
    microExpr: 0.25, eyeMove: 0.20, voiceStress: 0.25, nlp: 0.15, delay: 0.10, physio: 0.05
  };
  
  let weighted = 0, totalWeight = 0;
  Object.entries(weights).forEach(([key, w]) => {
    if(state.metrics[key] > 0) {
      weighted += state.metrics[key] * w;
      totalWeight += w;
    }
  });
  
  const raw = totalWeight > 0 ? weighted / totalWeight : 50;
  // Smooth transition
  state.truthScore += (raw - state.truthScore) * 0.1;
  state.truthScore = Math.max(0, Math.min(100, state.truthScore));
  
  // Update UI
  const score = state.truthScore;
  document.getElementById('scoreNumber').textContent = score.toFixed(0);
  
  // Ring
  const circumference = 364.4;
  const offset = circumference - (score / 100 * circumference);
  const ring = document.getElementById('truthRingFill');
  ring.style.strokeDashoffset = offset;
  
  let ringColor, verdictText, verdictColor;
  if(score >= 75) { ringColor = '#39ff14'; verdictText = 'TRUTHFUL'; verdictColor = '#39ff14'; }
  else if(score >= 55) { ringColor = '#00d4ff'; verdictText = 'LIKELY TRUTHFUL'; verdictColor = '#00d4ff'; }
  else if(score >= 40) { ringColor = '#ffb800'; verdictText = 'INCONCLUSIVE'; verdictColor = '#ffb800'; }
  else if(score >= 25) { ringColor = '#ff6b35'; verdictText = 'LIKELY DECEPTIVE'; verdictColor = '#ff6b35'; }
  else { ringColor = '#ff3c6e'; verdictText = 'DECEPTIVE'; verdictColor = '#ff3c6e'; }
  
  ring.style.stroke = ringColor;
  document.getElementById('scoreNumber').style.color = ringColor;
  
  const badge = document.getElementById('verdictBadge');
  badge.textContent = verdictText;
  badge.style.color = verdictColor;
  badge.style.borderColor = verdictColor;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TIMELINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateTimeline() {
  state.timelineData.push(state.truthScore < 50 ? 1 : 0);
  if(state.timelineData.length > 40) state.timelineData.shift();
  
  const row = document.getElementById('timelineRow');
  row.style.display = 'flex';
  const blocks = document.getElementById('timelineBlocks');
  blocks.innerHTML = '';
  
  state.timelineData.forEach(d => {
    const b = document.createElement('div');
    b.className = 'timeline-block';
    b.style.background = d ? 'rgba(255,60,110,0.5)' : 'rgba(57,255,20,0.3)';
    blocks.appendChild(b);
  });
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FEED ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let feedEventCount = 0;

function addFeedItem(type, text) {
  feedEventCount++;
  const feed = document.getElementById('analysisFeed');
  const elapsed = state.sessionStart ? Math.floor((Date.now() - state.sessionStart) / 1000) : 0;
  const mm = String(Math.floor(elapsed / 60)).padStart(2, '0');
  const ss = String(elapsed % 60).padStart(2, '0');
  
  const item = document.createElement('div');
  item.className = `feed-item ${type}`;
  item.innerHTML = `<span class="feed-time">${mm}:${ss}</span><span class="feed-text">${text}</span>`;
  
  feed.insertBefore(item, feed.firstChild);
  
  // Keep max 50 items
  while(feed.children.length > 50) feed.removeChild(feed.lastChild);
  
  document.getElementById('feedCount').textContent = `${feedEventCount} EVENTS`;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SESSION TIMER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startSessionTimer() {
  state.sessionStart = Date.now();
  state.sessionTimerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - state.sessionStart) / 1000);
    const hh = String(Math.floor(elapsed / 3600)).padStart(2, '0');
    const mm = String(Math.floor((elapsed % 3600) / 60)).padStart(2, '0');
    const ss = String(elapsed % 60).padStart(2, '0');
    document.getElementById('sessionTime').textContent = `${hh}:${mm}:${ss}`;
  }, 1000);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MAIN CONTROLS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function startAnalysis() {
  try {
    // Request camera + mic
    state.stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    
    const video = document.getElementById('videoFeed');
    video.srcObject = state.stream;
    await video.play();
    
    // Hide start screen
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('confOverlay').style.display = 'block';
    document.getElementById('recIndicator').classList.add('active');
    document.getElementById('scanLine').classList.add('active');
    
    // Update status
    document.getElementById('camStatus').className = 'status-dot';
    document.getElementById('camLabel').textContent = 'CAMERA LIVE';
    document.getElementById('micStatus').className = 'status-dot';
    document.getElementById('micLabel').textContent = 'MIC ACTIVE';
    document.getElementById('analysisMode').textContent = 'LIVE ANALYSIS';
    
    // Init audio
    await initAudio(state.stream);
    
    state.isRunning = true;
    
    // Start CV analysis
    startCVAnalysis();
    startSessionTimer();
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = false;
    
    addFeedItem('info', 'System online. Biometric capture active. Multi-modal analysis running.');
    addFeedItem('ok', 'Camera feed acquired. Face detection initialized.');
    addFeedItem('ok', 'Microphone active. Voice stress analyzer running.');

    // Periodic insight generator
    state.analysisInterval = setInterval(() => {
      if(!state.isRunning) return;
      generatePeriodicInsight();
    }, 4000);

  } catch(err) {
    addFeedItem('warn', `Camera/mic access denied: ${err.message}. Demo mode activated.`);
    startDemoMode();
  }
}

function startDemoMode() {
  // Run with simulated data if no camera access
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('confOverlay').style.display = 'block';
  document.getElementById('recIndicator').classList.add('active');
  document.getElementById('scanLine').classList.add('active');
  document.getElementById('analysisMode').textContent = 'DEMO MODE';
  document.getElementById('camStatus').className = 'status-dot warn';
  document.getElementById('camLabel').textContent = 'DEMO FEED';
  
  state.isRunning = true;
  
  // Simulate waveform on canvas
  const canvas = document.getElementById('waveformCanvas');
  const ctx = canvas.getContext('2d');
  
  function drawDemoWave() {
    if(!state.isRunning) return;
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,212,255,0.6)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    const t = Date.now() / 200;
    for(let x = 0; x < W; x++) {
      const y = H/2 + Math.sin(x/20 + t) * 10 + Math.sin(x/7 + t*1.3) * 5 + (Math.random()-0.5)*3;
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    requestAnimationFrame(drawDemoWave);
  }
  drawDemoWave();
  
  startCVAnalysis();
  startSessionTimer();
  
  document.getElementById('startBtn').disabled = true;
  document.getElementById('stopBtn').disabled = false;

  state.analysisInterval = setInterval(() => {
    if(!state.isRunning) return;
    generatePeriodicInsight();
    // Simulate demo voice stress
    const stress = Math.random() * 60 + 20;
    updateMetric('voice', 100 - stress, `PITCH VARIANCE: ${(stress*0.8).toFixed(0)} | TREMOR: ${stress>50?'HIGH':'LOW'}`, 'sub-voice');
  }, 400);

  addFeedItem('info', 'Demo mode active. Simulating multimodal behavioral signals.');
}

function stopAnalysis() {
  state.isRunning = false;
  
  if(state.stream) {
    state.stream.getTracks().forEach(t => t.stop());
    state.stream = null;
  }
  if(state.audioCtx) { state.audioCtx.close(); state.audioCtx = null; }
  if(state.analysisInterval) { clearInterval(state.analysisInterval); state.analysisInterval = null; }
  if(state.waveInterval) { clearInterval(state.waveInterval); state.waveInterval = null; }
  if(cvSimInterval) { clearInterval(cvSimInterval); }
  if(state.sessionTimerInterval) { clearInterval(state.sessionTimerInterval); }

  document.getElementById('recIndicator').classList.remove('active');
  document.getElementById('scanLine').classList.remove('active');
  document.getElementById('analysisMode').textContent = 'STOPPED';
  document.getElementById('camStatus').className = 'status-dot inactive';
  document.getElementById('micStatus').className = 'status-dot inactive';
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stopBtn').disabled = true;
  
  addFeedItem('info', `Analysis complete. Final truth score: ${state.truthScore.toFixed(0)}%`);
}

function resetAll() {
  stopAnalysis();
  state.truthScore = 50;
  state.metrics = { microExpr:0, eyeMove:0, voiceStress:0, nlp:0, delay:0, physio:0 };
  state.timelineData = [];
  feedEventCount = 0;
  
  document.getElementById('scoreNumber').textContent = '--';
  document.getElementById('verdictBadge').textContent = 'STANDBY';
  document.getElementById('verdictBadge').style.color = 'var(--text-dim)';
  document.getElementById('verdictBadge').style.borderColor = 'var(--text-dim)';
  document.getElementById('truthRingFill').style.strokeDashoffset = '364.4';
  document.getElementById('faceBox').className = 'face-box';
  document.getElementById('expressionTags').innerHTML = '';
  document.getElementById('nlpTags').innerHTML = '<span class="nlp-tag neutral">AWAITING INPUT</span>';
  document.getElementById('deceptionFlags').innerHTML = '<span style="font-family:\'Share Tech Mono\',monospace;font-size:9px;color:var(--text-dim);letter-spacing:1px;">NO FLAGS DETECTED</span>';
  document.getElementById('startScreen').style.display = 'flex';
  document.getElementById('analysisFeed').innerHTML = `
    <div class="feed-item info">
      <span class="feed-time">00:00</span>
      <span class="feed-text">System reset. Awaiting biometric input.</span>
    </div>`;
  document.getElementById('feedCount').textContent = '0 EVENTS';
  document.getElementById('sessionTime').textContent = '00:00:00';
  document.getElementById('stressViz').style.display = 'none';
  document.getElementById('timelineRow').style.display = 'none';
  
  ['micro','eye','voice','nlp','delay','physio'].forEach(k => {
    document.getElementById(`val-${k}`).textContent = '‚Äî';
    document.getElementById(`val-${k}`).style.color = 'var(--text-dim)';
    document.getElementById(`bar-${k}`).style.width = '0%';
  });
}

function exportReport() {
  const score = state.truthScore.toFixed(1);
  const elapsed = state.sessionStart ? Math.floor((Date.now() - state.sessionStart) / 1000) : 0;
  const verdict = document.getElementById('verdictBadge').textContent;
  
  const report = `
VERITAS DECEPTION ANALYSIS REPORT
Generated: ${new Date().toISOString()}
Session Duration: ${Math.floor(elapsed/60)}m ${elapsed%60}s
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

FINAL VERDICT: ${verdict}
TRUTH PROBABILITY: ${score}%
DECEPTION RISK: ${(100 - parseFloat(score)).toFixed(1)}%

CHANNEL SCORES:
‚Ä¢ Micro-Expressions:  ${state.metrics.microExpr.toFixed(1)}%
‚Ä¢ Eye Movement:       ${state.metrics.eyeMove.toFixed(1)}%
‚Ä¢ Voice Stress:       ${state.metrics.voiceStress.toFixed(1)}%
‚Ä¢ NLP Analysis:       ${state.metrics.nlp.toFixed(1)}%
‚Ä¢ Response Delay:     ${state.metrics.delay.toFixed(1)}%
‚Ä¢ Physiological:      ${state.metrics.physio.toFixed(1)}%

DECEPTION FLAGS:
${state.deceptionFlags.size > 0 ? Array.from(state.deceptionFlags).map(f => '‚Ä¢ ' + f).join('\n') : '‚Ä¢ None detected'}

NOTE: This system provides probabilistic behavioral indicators.
Results should be used as one factor in broader assessment.
`;
  
  const blob = new Blob([report], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `VERITAS_Report_${Date.now()}.txt`;
  a.click();
  
  addFeedItem('ok', 'Report exported successfully.');
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PERIODIC INSIGHTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const insightBank = [
  ['ok', 'Baseline calibration complete. Establishing normal behavioral parameters.'],
  ['info', 'Eye contact pattern: averaging 68% direct gaze ‚Äî within normal range.'],
  ['warn', 'Micro-expression: involuntary fear response detected ‚Äî 0.08 second duration.'],
  ['alert', 'Voice pitch elevated 12% above baseline ‚Äî stress marker identified.'],
  ['info', 'Blink rate stabilizing after initial arousal peak.'],
  ['warn', 'Gaze shift detected: leftward movement during factual recall ‚Äî may indicate confabulation.'],
  ['ok', 'Physiological signals within acceptable variance range.'],
  ['warn', 'Response latency spike: 847ms pause before answer ‚Äî cognitive load indicator.'],
  ['info', 'Facial muscle symmetry: 94% bilateral ‚Äî consistent with genuine expression.'],
  ['alert', 'Lip compression micromovement detected ‚Äî suppressed emotion signal.'],
  ['ok', 'Voice tremor subsiding. Subject may be gaining composure.'],
  ['warn', 'Nostril flare micro-expression ‚Äî fight-or-flight activation detected.'],
  ['info', 'Cross-modal consistency check: facial and vocal signals aligned.'],
  ['warn', 'Blink rate increased 40% ‚Äî heightened arousal state.'],
  ['ok', 'Language analysis: specific contextual details increase credibility score.'],
];

let insightIdx = 0;

function generatePeriodicInsight() {
  if(insightBank.length === 0) return;
  const insight = insightBank[insightIdx % insightBank.length];
  insightIdx++;
  addFeedItem(insight[0], insight[1]);
}

// Init stress segments
const segsEl = document.getElementById('stressSegments');
</script>
</body>
</html>
